# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m9AgDu3a_KaDSfFnHRXHYASJeAvmsyA0
"""

# streamlit_app.py
import streamlit as st
import pickle
import numpy as np
import pandas as pd
import re
from pathlib import Path
from sentence_transformers import SentenceTransformer
from sklearn.preprocessing import normalize

# ---------- Paths (update if different) ----------
RECOMMENDER_STATE = Path('/content/drive/MyDrive/NLP_RS/extracted/recommender_state.pkl')
EMB_PATH = Path('/content/drive/MyDrive/NLP_RS/extracted/course_embeddings.npy')

# ---------- Utilities ----------
@st.cache_resource
def load_state():
    with open(RECOMMENDER_STATE, 'rb') as f:
        state = pickle.load(f)
    # Ensure types
    emb_norm = state['emb_norm']
    df_small = state['df_small']
    return emb_norm, df_small

@st.cache_resource
def load_encoder():
    return SentenceTransformer('all-MiniLM-L6-v2')

def clean_text(text: str) -> str:
    text = str(text).lower()
    text = re.sub(r'[^a-z0-9\s]', ' ', text)
    tokens = text.split()
    # light stopword removal to keep app fast
    stopwords = {"the","and","a","an","of","in","for","to","with","on","by","from"}
    tokens = [t for t in tokens if t not in stopwords]
    return " ".join(tokens)

def top_k_from_sim(sim_vec, k=5, exclude_idx=None):
    sim = sim_vec.copy()
    if exclude_idx is not None:
        sim[exclude_idx] = -1.0
    idxs = np.argsort(-sim)[:k]
    return idxs, sim[idxs]

def recommend_by_index(idx, emb_norm, df_small, k=5):
    sim = emb_norm.dot(emb_norm[idx])
    idxs, scores = top_k_from_sim(sim, k=k, exclude_idx=idx)
    return format_results(idxs, scores, df_small)

def recommend_by_text(query, emb_norm, df_small, encoder, k=5):
    q_clean = clean_text(query)
    q_emb = encoder.encode([q_clean])
    q_emb_n = q_emb / np.linalg.norm(q_emb, axis=1, keepdims=True)
    sim = emb_norm.dot(q_emb_n[0])
    idxs, scores = top_k_from_sim(sim, k=k, exclude_idx=None)
    return format_results(idxs, scores, df_small)

def format_results(idxs, scores, df_small):
    rows = []
    for i, s in zip(idxs, scores):
        row = df_small.iloc[int(i)].to_dict()
        rows.append({
            "index": int(i),
            "course_title": row.get('course_title',''),
            "organization": row.get('course_organization',''),
            "rating": float(row.get('course_rating', np.nan)) if 'course_rating' in row else np.nan,
            "difficulty": row.get('course_difficulty',''),
            "score": float(s)
        })
    return rows

# ---------- App UI ----------
st.set_page_config(page_title="Course Recommender", layout="wide")
st.title("Content-based Course Recommender")

emb_norm, df_small = load_state()

mode = st.sidebar.radio("Recommendation mode", ["By example course", "By text query"])
k = st.sidebar.slider("Number of recommendations", min_value=1, max_value=10, value=5)

if mode == "By example course":
    st.sidebar.markdown("Choose a course to find similar courses.")
    course_list = df_small['course_title'].tolist()
    sel = st.sidebar.selectbox("Select course", options=["-- pick --"] + course_list)
    if sel != "-- pick --":
        idx = df_small.index[df_small['course_title'] == sel][0]
        st.subheader("Selected course")
        st.write(df_small.loc[idx, ['course_title','course_organization','course_rating','course_difficulty']])
        with st.spinner("Computing recommendations..."):
            recs = recommend_by_index(int(idx), emb_norm, df_small, k=k)
        st.subheader("Top recommendations")
        for r in recs:
            st.markdown(f"**{r['course_title']}**  \nOrg: {r['organization']}  \nRating: {r['rating']}  \nScore: {r['score']:.3f}")
            st.write("---")

else:
    st.sidebar.markdown("Enter a short query describing what you want to learn.")
    query = st.sidebar.text_area("Query (e.g., 'beginner machine learning with python')", height=80)
    if st.sidebar.button("Recommend") and query.strip():
        encoder = load_encoder()
        with st.spinner("Encoding query and computing recommendations..."):
            recs = recommend_by_text(query, emb_norm, df_small, encoder, k=k)
        st.subheader("Top recommendations for your query")
        for r in recs:
            st.markdown(f"**{r['course_title']}**  \nOrg: {r['organization']}  \nRating: {r['rating']}  \nScore: {r['score']:.3f}")
            st.write("---")

st.sidebar.markdown("## About")
st.sidebar.write("This app uses sentence-transformer embeddings precomputed for courses and cosine similarity for retrieval.")